<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mock DB API Console — JSONBin (Basic + Advanced)</title>
  <link rel="stylesheet" href="./demo.css" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;max-width:1000px;margin:2rem auto}
    .section-title{margin-top:2rem}
    .hint{opacity:.75;font-size:.9rem}
  </style>
</head>
<body>
  <h1>API Console — JSONBin Adapter</h1>
  <p>Enter a <strong>PUBLIC</strong> <code>BIN_ID</code> for your seeded doc, then run commands. This console uses GET/PUT with an optimistic <code>rev</code> check and <em>auto-fills</em> IDs to avoid broken examples.</p>

  <h2 class="section-title">Boot</h2>
  <div class="grid">
    <div class="card" id="bootCard">
      <div class="controls">
        <input id="binId" type="text" placeholder="BIN_ID (PUBLIC)" style="min-width:380px" />
        <button id="bootBtn" class="run-btn">Boot / Reload</button>
        <span id="stamp"></span>
      </div>
      <div class="hint">On boot, we ensure a demo todo and a demo tag exist and auto-fill the cards below.</div>
      <div id="bootConsole"></div>
    </div>
  </div>

  <h2 class="section-title">Basic CRUD</h2>
  <div class="grid">
    <!-- getDoc -->
    <div class="card">
      <label><strong>getDoc</strong> <small>(no input)</small></label>
      <div class="controls"><button id="getDocBtn" class="run-btn">Run</button></div>
      <div id="getDocConsole"></div>
    </div>

    <!-- findMany (predicate via where helper) -->
    <div class="card">
      <label><strong>findMany</strong>
        <small>{ "col": "todos", "where": { "field": "assignedTo", "op": "eq", "value": "u-alice" } }</small>
      </label>
      <textarea id="findManyInput">{ "col": "todos", "where": { "field": "assignedTo", "op": "eq", "value": "u-alice" } }</textarea>
      <div class="controls"><button id="findManyBtn" class="run-btn">Run</button></div>
      <div id="findManyConsole"></div>
    </div>

    <!-- findOne (predicate via where helper) -->
    <div class="card">
      <label><strong>findOne</strong>
        <small>{ "col": "users", "where": { "field": "name", "op": "eq", "value": "Alice" } }</small>
      </label>
      <textarea id="findOneInput">{ "col": "users", "where": { "field": "name", "op": "eq", "value": "Alice" } }</textarea>
      <div class="controls"><button id="findOneBtn" class="run-btn">Run</button></div>
      <div id="findOneConsole"></div>
    </div>

    <!-- insertOne -->
    <div class="card">
      <label><strong>insertOne</strong>
        <small>{ "col": "todos", "data": { "title": "From console", "done": false, "assignedTo": "u-bob", "projectId":"p-1", "tagIds":[], "subtasks":[], "commentIds":[] } }</small>
      </label>
      <textarea id="insertInput">{ "col": "todos", "data": { "title": "From console", "done": false, "assignedTo": "u-bob", "projectId":"p-1", "tagIds":[], "subtasks":[], "commentIds":[] } }</textarea>
      <div class="controls"><button id="insertBtn" class="run-btn">Run</button></div>
      <div id="insertConsole"></div>
    </div>

    <!-- updateOne -->
    <div class="card">
      <label><strong>updateOne</strong>
        <small>// id will be filled with a valid demo todo</small>
      </label>
      <textarea id="updateInput">{ "col": "todos", "id": "<todoId>", "patch": { "done": true } }</textarea>
      <div class="controls"><button id="updateBtn" class="run-btn">Run</button></div>
      <div id="updateConsole"></div>
    </div>

    <!-- deleteOne -->
    <div class="card">
      <label><strong>deleteOne</strong>
        <small>// id will be filled with a valid demo tag; re-Boot to recreate it</small>
      </label>
      <textarea id="deleteInput">{ "col": "tags", "id": "<tagId>" }</textarea>
      <div class="controls"><button id="deleteBtn" class="run-btn">Run</button></div>
      <div id="deleteConsole"></div>
    </div>
  </div>

  <h2 class="section-title">Advanced CRUD</h2>
  <div class="grid">
    <!-- findManyBy (filter object) -->
    <div class="card">
      <label><strong>findManyBy</strong>
        <small>{ "col": "todos", "filter": { "assignedTo": "u-alice", "done": false } }</small>
      </label>
      <textarea id="findManyByInput">{ "col": "todos", "filter": { "assignedTo": "u-alice", "done": false } }</textarea>
      <div class="controls"><button id="findManyByBtn" class="run-btn">Run</button></div>
      <div id="findManyByConsole"></div>
    </div>

    <!-- findOneBy (filter object) -->
    <div class="card">
      <label><strong>findOneBy</strong>
        <small>// name will be filled with the demo tag's name</small>
      </label>
      <textarea id="findOneByInput">{ "col": "tags", "filter": { "name": "<tagName>" } }</textarea>
      <div class="controls"><button id="findOneByBtn" class="run-btn">Run</button></div>
      <div id="findOneByConsole"></div>
    </div>

    <!-- find (projection/sort/limit/skip) -->
    <div class="card">
      <label><strong>find</strong>
        <small>{
          "col":"todos",
          "args":{"filter":{"done":false},"sort":{"title":1},"limit":3,"fields":{"id":1,"title":1}}
        }</small>
      </label>
      <textarea id="findInput">{
  "col": "todos",
  "args": {
    "filter": { "done": false },
    "sort": { "title": 1 },
    "limit": 3,
    "fields": { "id": 1, "title": 1 }
  }
}</textarea>
      <div class="controls"><button id="findBtn" class="run-btn">Run</button></div>
      <div id="findConsole"></div>
    </div>

    <!-- updateOneOps -->
    <div class="card">
      <label><strong>updateOneOps</strong>
        <small>// id will be filled with the demo todo id</small>
      </label>
      <textarea id="updateOpsInput">{
  "col": "todos",
  "id": "<todoId>",
  "ops": { "$addToSet": { "tagIds": "<tagId>" }, "$set": { "done": true } }
}</textarea>
      <div class="controls"><button id="updateOpsBtn" class="run-btn">Run</button></div>
      <div id="updateOpsConsole"></div>
    </div>

    <!-- upsertOne -->
    <div class="card">
      <label><strong>upsertOne</strong>
        <small>{ "col":"tags","filter":{"name":"priority"},"data":{"name":"priority"} }</small>
      </label>
      <textarea id="upsertInput">{
  "col": "tags",
  "filter": { "name": "priority" },
  "data": { "name": "priority" }
}</textarea>
      <div class="controls"><button id="upsertBtn" class="run-btn">Run</button></div>
      <div id="upsertConsole"></div>
    </div>

    <!-- transact -->
    <div class="card">
      <label><strong>transact</strong>
        <small>// JS body to run inside transact(doc => { ... })</small>
      </label>
      <textarea id="transactInput">
// Adds tag t-batch-cloud if missing and attaches it to first todo
const t = doc.tags.find(x => x.id === "t-batch-cloud");
if (!t) doc.tags.push({ id: "t-batch-cloud", name: "batch-cloud" });
if (doc.todos[0]) {
  const set = new Set([...(doc.todos[0].tagIds || []), "t-batch-cloud"]);
  doc.todos[0].tagIds = Array.from(set);
}
      </textarea>
      <div class="controls"><button id="transactBtn" class="run-btn">Run</button></div>
      <div id="transactConsole"></div>
    </div>
  </div>

  <script type="module">
    import { createConsoleSink, gentleParse, buildPredicate, pretty } from "./demo-runner.js";
    import * as api from "../tests/db-tracer.js";
    import { jsonBinAdapter } from "../scripts/adapters/jsonBinAdapter.js";
    import { findManyBy, findOneBy, find, updateOneOps, upsertOne } from "../scripts/db.js";

    const bootSink = createConsoleSink(document.getElementById("bootConsole"));
    const stamp = document.getElementById("stamp");
    const binInput = document.getElementById("binId");

    // in-page state for demo placeholders
    const state = { demoTodoId: null, demoTagId: null, demoTagName: null, booted: false };

    async function ensureDemoTodo() {
      const first = api.findMany("todos")[0];
      if (first) return first.id;
      const t = await api.insertOne("todos", {
        title:"Demo todo (cloud)", done:false, assignedTo:"u-alice",
        projectId:"p-1", tagIds:[], subtasks:[], commentIds:[]
      });
      return t.id;
    }

    async function ensureDemoTag() {
      // use upsert to create a deterministic tag if missing
      const existing = findOneBy("tags", { name: "demo-tag" });
      if (existing) return { id: existing.id, name: existing.name };
      const made = await upsertOne("tags", { name: "demo-tag" }, { name: "demo-tag" });
      return { id: made.id, name: made.name };
    }

    function fillPlaceholders() {
      const fields = ["updateInput","deleteInput","updateOpsInput","findOneByInput"];
      for (const id of fields) {
        const el = document.getElementById(id);
        if (!el) continue;
        el.value = el.value
          .replace(/<todoId>/g, state.demoTodoId)
          .replace(/<tagId>/g, state.demoTagId)
          .replace(/<tagName>/g, state.demoTagName);
      }
    }

    async function bootNow(){
      const id = binInput.value.trim();
      if (!id) { bootSink.log("Enter BIN_ID first."); return; }
      api.useAdapter(jsonBinAdapter(id));
      const doc = await api.boot();
      // ensure demo entities exist and capture IDs
      state.demoTodoId = await ensureDemoTodo();
      const tag = await ensureDemoTag();
      state.demoTagId = tag.id; state.demoTagName = tag.name;

      // fill placeholders
      fillPlaceholders();

      // mark booted
      state.booted = true;

      stamp.textContent = "rev=" + doc.rev + " • updated " + new Date(doc.updatedAt).toLocaleString();
      bootSink.log("Booted remote doc with " + (doc.users?.length ?? 0) + " users, " + (doc.todos?.length ?? 0) + " todos");
      bootSink.log("Demo todo id = " + state.demoTodoId + " | Demo tag id = " + state.demoTagId + " (name=" + state.demoTagName + ")");
    }
    document.getElementById("bootBtn").addEventListener("click", bootNow);

    function requireBoot(sink) {
      if (!state.booted) { sink.log("Enter BIN_ID and click Boot / Reload first."); return false; }
      if (!binInput.value.trim()) { sink.log("Enter BIN_ID first."); return false; }
      return true;
    }

    function hook(btnId, sinkId, fn){
      const sink = createConsoleSink(document.getElementById(sinkId));
      document.getElementById(btnId).addEventListener("click", async () => {
        try {
          if (!requireBoot(sink)) return;
          const out = await fn();
          if (out !== undefined) sink.log(pretty(out));
        } catch (e) { sink.log("ERROR: " + e.message); }
      });
    }

    // --- BASIC ---
    hook("getDocBtn", "getDocConsole", async () => api.getDoc());

    hook("findManyBtn", "findManyConsole", async () => {
      const { col, where } = gentleParse(document.getElementById("findManyInput").value);
      return api.findMany(col, buildPredicate(where));
    });

    hook("findOneBtn", "findOneConsole", async () => {
      const { col, where } = gentleParse(document.getElementById("findOneInput").value);
      return api.findOne(col, buildPredicate(where));
    });

    hook("insertBtn", "insertConsole", async () => {
      const { col, data } = gentleParse(document.getElementById("insertInput").value);
      const rec = await api.insertOne(col, data);
      if (col === "todos") { state.demoTodoId = rec.id; fillPlaceholders(); }
      return rec;
    });

    hook("updateBtn", "updateConsole", async () => {
      const { col, id, patch } = gentleParse(document.getElementById("updateInput").value);
      const n = await api.updateOne(col, id, patch);
      return { updated: n, row: api.findOne(col, r => r.id === id) };
    });

    hook("deleteBtn", "deleteConsole", async () => {
      const { col, id } = gentleParse(document.getElementById("deleteInput").value);
      const n = await api.deleteOne(col, id);
      // If we deleted the demo tag, recreate for later cards
      if (col === "tags" && id === state.demoTagId && n === 1) {
        const tag = await upsertOne("tags", { name: "demo-tag" }, { name: "demo-tag" });
        state.demoTagId = tag.id; state.demoTagName = tag.name; fillPlaceholders();
      }
      return { deleted: n };
    });

    // --- ADVANCED ---
    hook("findManyByBtn", "findManyByConsole", async () => {
      const { col, filter } = gentleParse(document.getElementById("findManyByInput").value);
      return findManyBy(col, filter || {});
    });

    hook("findOneByBtn", "findOneByConsole", async () => {
      const { col, filter } = gentleParse(document.getElementById("findOneByInput").value);
      return findOneBy(col, filter || {});
    });

    hook("findBtn", "findConsole", async () => {
      const { col, args } = gentleParse(document.getElementById("findInput").value);
      return find(col, args || {});
    });

    hook("updateOpsBtn", "updateOpsConsole", async () => {
      const { col, id, ops } = gentleParse(document.getElementById("updateOpsInput").value);
      const n = await updateOneOps(col, id, ops || {});
      const row = api.findOne(col, r => r.id === id);
      return { updated: n, row };
    });

    hook("upsertBtn", "upsertConsole", async () => {
      const { col, filter, data } = gentleParse(document.getElementById("upsertInput").value);
      return await upsertOne(col, filter || {}, data || {});
    });

    hook("transactBtn", "transactConsole", async () => {
      const body = document.getElementById("transactInput").value;
      await api.transact(new Function("doc", body));
      return api.getDoc();
    });
  </script>
</body>
</html>
