<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MockDB Tests — Local Storage (Basic + Advanced)</title>
  <link rel="stylesheet" href="./console.css" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;max-width:900px;margin:2rem auto}
  </style>
</head>
<body>
  <h1>MockDB Tests — Local Storage</h1>
  <p>Runs <strong>basic CRUD</strong> (Part 1) and <strong>advanced CRUD</strong> (Part 2) against the LocalStorage adapter.</p>
  <ol id="out"></ol>

  <script type="module">
    import { runTests } from "./test-runner.js";
    // tracer-wrapped core API: useAdapter, boot, getDoc, findMany, findOne, insertOne, updateOne, deleteOne, transact
    import * as api from "./db-tracer.js";
    import { localStorageAdapter } from "../scripts/adapters/localStorageAdapter.js";

    // Advanced helpers exported from your revised ../scripts/db.js
    import {
      findManyBy, findOneBy, find,
      updateOneOps, upsertOne
    } from "../scripts/db.js";

    // --- Wire adapter ---
    api.useAdapter(localStorageAdapter);

    // -------- BASIC CRUD --------

    await runTests("Step 1: Boot & Seed (LocalStorage)", async ({assert, console}) => {
      const doc = await api.boot();
      console("Loaded doc rev=" + doc.rev);
      assert(!!doc.users?.length, "seed users exist");
      assert(Array.isArray(doc.todos), "todos array present");
      assert(Array.isArray(doc.tags),  "tags array present");
    });

    await runTests("Step 2: CREATE", async ({assert, console}) => {
      const before = (api.getDoc().users || []).length;
      const rec = await api.insertOne("users", { name: "Carol" });
      const after = api.getDoc().users.length;
      console("Inserted user: " + JSON.stringify(rec, null, 2));
      assert(!!rec.id, "insert returns record with id");
      assert(after === before + 1, "user count increased");
    });

    await runTests("Step 3: READ", async ({assert, console}) => {
      const users = api.findMany("users");
      const carol = api.findOne("users", u => u.name === "Carol");
      console("Users: " + JSON.stringify(users, null, 2));
      assert(Array.isArray(users), "findMany returns array");
      assert(!!carol, "findOne locates Carol");
    });

    await runTests("Step 4: UPDATE", async ({assert, console}) => {
      const t = await api.insertOne("todos", {
        title:"Draft syllabus", done:false, assignedTo:"u-bob",
        projectId:"p-1", tagIds:[], subtasks:[], commentIds:[]
      });
      const n = await api.updateOne("todos", t.id, { done:true });
      const updated = api.findOne("todos", x => x.id === t.id);
      console("Updated todo: " + JSON.stringify(updated, null, 2));
      assert(n === 1, "updateOne returns 1");
      assert(updated.done === true, "todo marked done");
    });

    await runTests("Step 5: DELETE", async ({assert, console}) => {
      const tag = await api.insertOne("tags", { name: "temp-tag" });
      const d = await api.deleteOne("tags", tag.id);
      const still = api.findOne("tags", x => x.id === tag.id);
      console("Deleted tag id: " + tag.id);
      assert(d === 1, "deleteOne returns 1");
      assert(!still, "record removed");
    });

    // Optional persistence sanity check (LocalStorage should persist across re-boot in the same page)
    await runTests("Persistence: Reboot should keep prior changes", async ({assert, console}) => {
      const before = api.getDoc().rev ?? 0;
      const re = await api.boot(); // reload from LocalStorage again
      console("Rebooted doc rev=" + re.rev);
      assert((re.rev ?? 0) >= before, "re-boot returns same or newer rev from storage");
    });

    // -------- ADVANCED CRUD --------

    await runTests("Advanced — Filter Objects (findManyBy / findOneBy)", async ({assert, console}) => {
      // Precondition: seed has a todo assignedTo u-alice and done=false
      const r1 = findManyBy("todos", { assignedTo: "u-alice", done: false });
      console("findManyBy todos (u-alice & open): " + r1.length);
      assert(Array.isArray(r1), "findManyBy returns array");
      assert(r1.length >= 0, "filter ran without error");

      const tagSetup = findOneBy("tags", { name: "setup" });
      console("findOneBy tags (name=setup): " + JSON.stringify(tagSetup));
      assert(tagSetup ? tagSetup.name === "setup" : true, "findOneBy runs (tag may be present in seed)");
    });

    await runTests("Advanced — Projection / Sort / Paging (find)", async ({assert, console}) => {
      const rows = find("todos", {
        filter: { done: false },
        sort: { title: 1 },
        limit: 3,
        fields: { id: 1, title: 1 }
      });
      console("find() projected rows: " + JSON.stringify(rows, null, 2));
      assert(Array.isArray(rows), "find returns array");
      assert(rows.length <= 3, "limit applied");
      if (rows[0]) {
        assert("id" in rows[0] && "title" in rows[0], "projection includes id/title");
        assert(!("assignedTo" in rows[0]), "projection excludes unspecified fields");
      }
    });

    await runTests("Advanced — updateOneOps ($set / $addToSet / $pull)", async ({assert, console}) => {
      // Work with a fresh todo to avoid collisions
      const t = await api.insertOne("todos", {
        title:"AdvOps", done:false, assignedTo:"u-bob",
        projectId:"p-1", tagIds:[], subtasks:[], commentIds:[]
      });

      // $addToSet + $set
      const n1 = await updateOneOps("todos", t.id, {
        $addToSet: { tagIds: "t-web" },
        $set: { done: true }
      });
      const after1 = api.findOne("todos", x => x.id === t.id);
      console("After $addToSet/$set: " + JSON.stringify(after1, null, 2));
      assert(n1 === 1, "updateOneOps returns 1 for addToSet/set");
      assert(after1.done === true, "done updated");
      assert((after1.tagIds || []).includes("t-web"), "tagIds contains t-web");

      // $pull
      const n2 = await updateOneOps("todos", t.id, { $pull: { tagIds: "t-web" } });
      const after2 = api.findOne("todos", x => x.id === t.id);
      console("After $pull: " + JSON.stringify(after2, null, 2));
      assert(n2 === 1, "updateOneOps returns 1 for pull");
      assert(!(after2.tagIds || []).includes("t-web"), "tagIds no longer contains t-web");
    });

    await runTests("Advanced — upsertOne (create-or-update)", async ({assert, console}) => {
      const pre = find("tags", { filter: { name: "priority" } });
      console("Existing priority tags (before): " + pre.length);

      const a = await upsertOne("tags", { name: "priority" }, { name: "priority" });
      const mid = find("tags", { filter: { name: "priority" } });
      console("After first upsert count: " + mid.length);
      assert(mid.length >= 1, "upsert created or updated tag 'priority'");

      const b = await upsertOne("tags", { name: "priority" }, { name: "priority" });
      const post = find("tags", { filter: { name: "priority" } });
      console("After second upsert count: " + post.length);
      assert(post.length === 1, "upsert did not create a duplicate");
    });

    await runTests("Advanced — transact (batch save)", async ({assert, console}) => {
      await api.transact(doc => {
        if (!doc.tags.find(t => t.id === "t-batch-ls"))
          doc.tags.push({ id: "t-batch-ls", name: "batch-ls" });
        const first = doc.todos[0];
        if (first) {
          const set = new Set([...(first.tagIds || []), "t-batch-ls"]);
          first.tagIds = Array.from(set);
        }
      });
      const hasTag = !!findOneBy("tags", { name: "batch-ls" });
      const firstTodo = api.findMany("todos")[0];
      const attached = (firstTodo?.tagIds || []).includes("t-batch-ls");
      console("Transact attached 't-batch-ls' to first todo");
      assert(hasTag, "batch created tag");
      assert(attached, "batch attached tag to first todo");
    });

    // Optional: persistence re-check after advanced ops
    await runTests("Persistence Re-check: Reboot after advanced ops", async ({assert, console}) => {
      const snapBefore = api.getDoc();
      const revBefore = snapBefore.rev ?? 0;
      const again = await api.boot();
      console("Rebooted doc rev=" + again.rev);
      assert((again.rev ?? 0) >= revBefore, "rev is same or newer after reboot");
      // After reload, the batch tag should still exist
      const stillHasBatch = !!findOneBy("tags", { name: "batch-ls" });
      assert(stillHasBatch, "LocalStorage persisted batch changes across boot()");
    });
  </script>
</body>
</html>
